#pragma once

#include "enumerations/specfem_enums.hpp"
#include "specfem/point.hpp"
#include <Kokkos_Core.hpp>

namespace specfem {
namespace iterator {

namespace impl {
/**
 * @brief Index type for quadrature points generated by the edge iterator.
 *
 * @tparam DimensionTag Dimension type of the elements where the edge is
 * defined
 */
template <specfem::dimension::type DimensionTag> struct edge_index_type {

  constexpr static auto dimension =
      DimensionTag; ///< Dimension type of the elements where the edge is
                    ///< defined
  const int iedge;  ///< Index of the edge within the range of edges
  specfem::point::index<dimension> self_index; ///< Index of the quadrature
                                               ///< point on the edge within the
                                               ///< current element
  specfem::point::index<dimension> coupled_index; ///< Index of the quadrature
                                                  ///< point on the edge within
                                                  ///< the coupled element

  KOKKOS_INLINE_FUNCTION
  edge_index_type(const int iedge,
                  const specfem::point::index<dimension> &self_index,
                  const specfem::point::index<dimension> &coupled_index)
      : iedge(iedge), self_index(self_index), coupled_index(coupled_index) {}
};
} // namespace impl

/**
 * @brief Iterator to generate indices for quadrature points defined on the edge
 *
 * @tparam DimensionTag Dimension type of the elements where the edge is
 * defined
 */
template <specfem::dimension::type DimensionTag> struct edge;

/**
 * @brief Template specialization for 2D elements
 *
 */
template <> struct edge<specfem::dimension::type::dim2> {
public:
  /**
   * @name Compile-time constants
   *
   */
  ///@{
  constexpr static auto dimension =
      specfem::dimension::type::dim2; ///< Dimension type
  ///@}

  /**
   * @name Type definitions
   *
   */
  ///@{
  using simd =
      specfem::datatype::simd<type_real, false>; ///< SIMD configuration
  using index_type = typename impl::edge_index_type<dimension>; ///< Index type
  ///@}

private:
  int iedge;           ///< Index of the edge within the range of edges
  int self_element;    ///< Index of the element where the edge is defined
  int coupled_element; ///< Index of the element with whom the edge is shared
  specfem::enums::edge::type self_edge;    ///< Edge orientation for the current
                                           ///< element
  specfem::enums::edge::type coupled_edge; ///< Edge orientation for the other
                                           ///< element
  int npoints;                             ///< Number of GLL points on the edge

public:
  /**
   * @name Constructors
   *
   */
  ///@{

  /**
   * @brief Construct a new edge iterator given edge indices, edge orientations.
   *
   * @param iedge Index of the edge within the range of edges
   * @param self_element Index of the element where the edge is defined
   * @param coupled_element Index of the element with whom the edge is shared
   * @param self_edge Edge orientation for the current element
   * @param coupled_edge Edge orientation for the other element
   * @param ngll Number of GLL points on the edge
   * @return KOKKOS_INLINE_FUNCTION
   */
  KOKKOS_INLINE_FUNCTION
  edge(const int iedge, const int self_element, const int coupled_element,
       const specfem::enums::edge::type self_edge,
       const specfem::enums::edge::type coupled_edge, const int ngll)
      : iedge(iedge), self_element(self_element),
        coupled_element(coupled_element), self_edge(self_edge),
        coupled_edge(coupled_edge), npoints(ngll) {}

  ///@}

  /**
   * @brief Get the number of quadrature points on the edge.
   *
   * @return int Number of quadrature points on the edge
   */
  KOKKOS_INLINE_FUNCTION
  int edge_size() const { return npoints; }

  /**
   * @brief Get the index of the i-th quadrature point on the edge.
   *
   * @param i Index of the quadrature point on the edge
   * @return index_type Index of the quadrature point
   */
  KOKKOS_INLINE_FUNCTION
  index_type operator()(const int i) const {
    const auto self_index = this->self_index(i);
    const auto coupled_index = this->coupled_index(i);
    return index_type(iedge, self_index, coupled_index);
  }

private:
  KOKKOS_INLINE_FUNCTION
  specfem::point::index<dimension> self_index(const int ipoint) const {
    switch (self_edge) {
    case specfem::enums::edge::type::BOTTOM:
      return { self_element, 0, ipoint };
      break;
    case specfem::enums::edge::type::TOP:
      return { self_element, npoints - 1, npoints - 1 - ipoint };
      break;
    case specfem::enums::edge::type::LEFT:
      return { self_element, ipoint, 0 };
      break;
    case specfem::enums::edge::type::RIGHT:
      return { self_element, npoints - 1 - ipoint, npoints - 1 };
      break;
    default:
      DEVICE_ASSERT(false, "Invalid edge type");
      return { 0, 0, 0 };
    }
  }

  KOKKOS_INLINE_FUNCTION
  specfem::point::index<dimension> coupled_index(const int ipoint) const {
    switch (coupled_edge) {
    case specfem::enums::edge::type::BOTTOM:
      return { coupled_element, 0, npoints - 1 - ipoint };
      break;
    case specfem::enums::edge::type::TOP:
      return { coupled_element, npoints - 1, ipoint };
      break;
    case specfem::enums::edge::type::LEFT:
      return { coupled_element, npoints - 1 - ipoint, npoints - 1 };
      break;
    case specfem::enums::edge::type::RIGHT:
      return { coupled_element, ipoint, 0 };
      break;
    default:
      DEVICE_ASSERT(false, "Invalid edge type");
      return { 0, 0, 0 };
    }
  }
};

} // namespace iterator

namespace policy {

/**
 * @brief Policy for iterating over quadrature points on range of shared edges
 * between 2 elements.
 *
 * @tparam ParallelConfig Parallel configuration for element edge policy. @ref
 * specfem::parallel_config::edge_config
 */
template <typename ParallelConfig>
struct element_edge
    : public Kokkos::TeamPolicy<typename ParallelConfig::execution_space> {
public:
  /**
   * @name Type definitions
   *
   */
  ///@{
  using simd =
      specfem::datatype::simd<type_real, false>; ///< SIMD configuration. SIMD
                                                 ///< is ill-defined for single
                                                 ///< edge case.
  using execution_space =
      typename ParallelConfig::execution_space;            ///< Execution space
  using policy_type = Kokkos::TeamPolicy<execution_space>; ///< Policy type
  using member_type = typename policy_type::member_type;   ///< Member type
  using iterator_type =
      specfem::iterator::edge<ParallelConfig::dimension>; ///< Iterator type
  ///@}

  /**
   * @name Compile-time constants
   *
   */
  ///@{
  constexpr static int num_threads =
      ParallelConfig::num_threads; ///< Chunk size
  constexpr static int vector_lanes =
      ParallelConfig::vector_lanes; ///< Vector lanes
  constexpr static auto dimension =
      ParallelConfig::dimension;               ///< Dimension type
  constexpr static bool isPointPolicy = false; ///< Indicates whether this is a
                                               ///< point policy or not
  constexpr static bool isEdgePolicy = true;   ///< Indicates whether this is an
                                               ///< edge policy or not
  constexpr static bool isFacePolicy = false;  ///< Indicates whether this is a
                                               ///< face policy or not
  constexpr static bool isElementPolicy =
      false; ///< Indicates whether this is an element policy or not
  ///@}

private:
  using IndexViewType = Kokkos::View<
      int *, typename member_type::execution_space::memory_space>; ///< View
                                                                   ///< type for
                                                                   ///< storing
                                                                   ///< indices
  using EdgeViewType = Kokkos::View<
      specfem::enums::edge::type *,
      typename member_type::execution_space::memory_space>; ///< View type for
                                                            ///< storing edge
                                                            ///< orientation

public:
  /**
   * @name Constructors
   *
   */
  ///@{
  /**
   * @brief Construct a new element edge policy based on indices and edges for
   * elements on edges.
   *
   * @param _self_indices Indices of the elements on the edge for the current
   * element
   * @param _coupled_indices Indices of the elements on the edge for the other
   * element
   * @param _self_edges Edge orientation for the current element
   * @param _coupled_edges Edge orientation for the other element
   * @param npoints Number of GLL points on the edge
   */
  element_edge(const IndexViewType _self_indices,
               const IndexViewType _coupled_indices,
               const EdgeViewType _self_edges,
               const EdgeViewType _coupled_edges, const int npoints)
      : policy_type(_self_indices.extent(0), Kokkos::AUTO, Kokkos::AUTO),
        self_indices(_self_indices), coupled_indices(_coupled_indices),
        self_edges(_self_edges), coupled_edges(_coupled_edges),
        npoints(npoints) {

    const int nedges = _self_indices.extent(0);

    if (nedges != _coupled_indices.extent(0)) {
      throw std::runtime_error("Number of edges must be equal");
    }

    if (nedges != _self_edges.extent(0)) {
      throw std::runtime_error("Number of edges must be equal");
    }

    if (nedges != _coupled_edges.extent(0)) {
      throw std::runtime_error("Number of edges must be equal");
    }
  }
  ///@}

  /**
   * @name Implicit conversion to the underlying Kokkos team policy type
   *
   */
  operator const policy_type &() const { return *this; }

  /**
   * @brief Get the iterator to generate indices for quadrature points defined
   * on this edge.
   *
   * @param iedge Index of the edge
   * @return iterator_type Iterator to generate indices for quadrature points
   * defined on this edge
   */
  KOKKOS_INLINE_FUNCTION
  iterator_type league_iterator(const int iedge) const {
    return iterator_type(iedge, self_indices(iedge), coupled_indices(iedge),
                         self_edges(iedge), coupled_edges(iedge), npoints);
  }

private:
  IndexViewType self_indices; ///< Indices of the elements on the edge for the
                              ///< current element
  IndexViewType coupled_indices; ///< Indices of the elements on the edge for
                                 ///< the other element
  EdgeViewType self_edges;       ///< Edge orientation for the current element
  EdgeViewType coupled_edges;    ///< Edge orientation for the other element
  int npoints;                   ///< Number of GLL points on the edge
};

} // namespace policy
} // namespace specfem
