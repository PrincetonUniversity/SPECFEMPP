#pragma once

#include "edge/index.hpp"
#include "enumerations/dimension.hpp"
#include "point/coordinates.hpp"
#include <Kokkos_Core.hpp>
#include <string>
#include <tuple>
#include <type_traits>

KOKKOS_INLINE_FUNCTION
static void zx_on_edge(int &iz, int &ix, const int igll,
                       const specfem::enums::edge::type edge, const int ngll) {
  switch (edge) {
  case specfem::enums::edge::type::TOP:
    iz = ngll - 1;
    ix = igll;
    break;
  case specfem::enums::edge::type::BOTTOM:
    iz = 0;
    ix = igll;
    break;
  case specfem::enums::edge::type::LEFT:
    iz = igll;
    ix = 0;
    break;
  case specfem::enums::edge::type::RIGHT:
    iz = igll;
    ix = ngll - 1;
    break;
  default: // none
    break;
  }
}

namespace specfem {
namespace iterator {

namespace impl {
/**
 * @brief Struct to store the index of a quadrature point generated by chunk
 * policy.
 *
 * @tparam UseSIMD Indicates whether SIMD is used or not.
 * @tparam DimensionType Dimension type of the elements within this iterator.
 */
template <bool UseSIMD, specfem::dimension::type DimensionType>
struct chunk_edge_pointwise_index_type {
  constexpr static auto dimension = DimensionType; ///< Dimension type
  int ielement;                    ///< Element index within the iterator range
  int igll;                        ///< point index along the edge
  specfem::enums::edge::type edge; ///< Edge associated with this iteration
  specfem::point::index<dimension, UseSIMD> index; ///< Index of the quadrature
                                                   ///< point

  KOKKOS_INLINE_FUNCTION
  chunk_edge_pointwise_index_type(
      const int ielement, const int igll, specfem::enums::edge::type edge,
      const specfem::point::index<dimension, UseSIMD> index)
      : ielement(ielement), index(index), igll(igll), edge(edge){};
};
} // namespace impl

/**
 * @brief Iterator to generate indices for quadrature points defined within this
 * iterator.
 *
 * @tparam ViewType View type for the indices of elements within this iterator.
 * @tparam DimensionType Dimension type of the elements within this iterator.
 * @tparam SIMD SIMD type to use simd operations @ref specfem::datatypes::simd
 */
template <typename IndexViewType, specfem::dimension::type DimensionType,
          typename SIMD>
class chunk_edge;

/**
 * @brief Template specialization for 2D elements.
 *
 */
template <typename IndexViewType, typename SIMD>
class chunk_edge<IndexViewType, specfem::dimension::type::dim2, SIMD> {
public:
  /**
   * @name Compile-time constants
   *
   */
  ///@{
  constexpr static auto dimension =
      specfem::dimension::type::dim2; ///< Dimension type
  ///@}

  /**
   * @name Type definitions
   *
   */
  ///@{
  using simd = SIMD; ///< SIMD type
  using index_type =
      typename impl::chunk_edge_pointwise_index_type<simd::using_simd,
                                                     dimension>; ///< Index
                                                                 ///< type
  ///@}

private:
  constexpr static bool using_simd = simd::using_simd;
  constexpr static int simd_size = simd::size();

  IndexViewType indices; ///< View of ispec indices of entries within
                         ///< this iterator
  int num_elements;      ///< Number of elements within this iterator
  int ngll;              ///< Number of GLL points along each edge

  KOKKOS_INLINE_FUNCTION
  chunk_edge(const IndexViewType &indices, const int ngll, std::true_type)
      : indices(indices), num_elements(indices.extent(0) / simd_size +
                                       (indices.extent(0) % simd_size != 0)),
        ngll(ngll) {}

  KOKKOS_INLINE_FUNCTION
  chunk_edge(const IndexViewType &indices, const int ngll, std::false_type)
      : indices(indices), num_elements(indices.extent(0)), ngll(ngll) {}

  KOKKOS_INLINE_FUNCTION
  impl::chunk_edge_pointwise_index_type<false, dimension>
  operator()(const int i, std::false_type) const {
#ifdef KOKKOS_ENABLE_CUDA
    int ielement = i % num_elements;
    int igll = i / num_elements;
#else
    const int igll = i % ngll;
    const int ielement = i / ngll;
#endif
    const auto index = indices(ielement);
    const int ispec = index.ispec;
    const auto edge = index.edge_type;
    int iz, ix;
    zx_on_edge(iz, ix, igll, edge, ngll);
    return impl::chunk_edge_pointwise_index_type<false, dimension>(
        ielement, igll, edge, specfem::point::index<dimension>(ispec, iz, ix));
  }

  KOKKOS_INLINE_FUNCTION
  impl::chunk_edge_pointwise_index_type<true, dimension>
  operator()(const int i, std::true_type) const {
#ifdef KOKKOS_ENABLE_CUDA
    int ielement = i % num_elements;
    int simd_elements = (simd_size + ielement > indices.extent(0))
                            ? indices.extent(0) - ielement
                            : simd_size;
    int igll = i / num_elements;
#else
    const int igll = i % ngll;
    const int ielement = i / ngll;
    int simd_elements = (simd_size + ielement > indices.extent(0))
                            ? indices.extent(0) - ielement
                            : simd_size;
#endif
    const auto index = indices(ielement);
    const int ispec = index.ispec;
    const auto edge = index.edge_type;
    int iz, ix;
    zx_on_edge(iz, ix, igll, edge, ngll);
    return impl::chunk_edge_pointwise_index_type<true, dimension>(
        ielement, igll, edge,
        specfem::point::simd_index<dimension>(ispec, simd_elements, iz, ix));
  }

public:
  /**
   * @name Constructors
   *
   */
  ///@{
  /**
   * @brief Construct a new chunk iterator with a given view of indices.
   *
   * @param indices View of indices of elements within this iterator
   * @param ngll Number of GLL points along each edge
   */
  KOKKOS_INLINE_FUNCTION
  chunk_edge(const IndexViewType &indices, int ngll)
      : chunk_edge(indices, ngll, std::integral_constant<bool, using_simd>()) {
#if KOKKOS_VERSION < 40100
    static_assert(IndexViewType::Rank == 1, "View must be rank 1");
#else
    static_assert(IndexViewType::rank() == 1, "View must be rank 1");
#endif
    // It should be safe to assume iterator view types have same extent.
    // if(indices.extent(0) != edges.extent(0)){
    //   throw std::runtime_error("Attempting to create a chunk_edge policy with
    //   unequally sized views for element index and edge type.");
    // }
  }
  ///@}

  /**
   * @brief Return the number of quadrature points within this chunk.
   *
   * @return int Number of quadrature points within this chunk
   */
  KOKKOS_FORCEINLINE_FUNCTION
  int chunk_size() const { return num_elements * ngll; }

  /**
   * @brief Returns the index within this iterator at the i-th quadrature point.
   *
   * @param i Index of the quadrature point within this iterator.
   * @return index_type Index of the quadrature point.
   */
  KOKKOS_INLINE_FUNCTION
  index_type operator()(const int i) const {
    return operator()(i, std::integral_constant<bool, using_simd>());
  }
};
} // namespace iterator

// TODO all above this is same as chunk.hpp
// change it.
//==============================================================

namespace policy {

/**
 * @brief edge chunk policy to chunk a group of element edges into Kokkos teams
 * and iterate over all the quadrature points within those chunks.
 *
 * @tparam ParallelConfig Parallel configuration for edge chunk policy.
 */
template <typename ParallelConfig>
struct chunk_edge
    : public Kokkos::TeamPolicy<typename ParallelConfig::execution_space> {

private:
  using IndexViewType = Kokkos::View<
      specfem::edge::index<ParallelConfig::dimension,
                           ParallelConfig::simd::using_simd> *,
      typename ParallelConfig::execution_space::memory_space>; ///< View
                                                               ///< type for
                                                               ///< indices

public:
  /**
   * @name Type definitions
   *
   */
  ///@{
  using simd = typename ParallelConfig::simd; ///< SIMD configuration
  using execution_space =
      typename ParallelConfig::execution_space;            ///< Execution space
  using policy_type = Kokkos::TeamPolicy<execution_space>; ///< Policy type
  using member_type = typename policy_type::member_type;   ///< Member type
  using iterator_type =
      specfem::iterator::chunk_edge<IndexViewType, ParallelConfig::dimension,
                                    simd>; ///< Iterator
                                           ///< type
  ///@}

  /**
   * @name Compile-time constants
   *
   */
  ///@{
  constexpr static int chunk_size = ParallelConfig::chunk_size; ///< Chunk size
  constexpr static int num_threads =
      ParallelConfig::num_threads; ///< Chunk size
  constexpr static int vector_lanes =
      ParallelConfig::vector_lanes;                           ///< Vector lanes
  constexpr static int tile_size = ParallelConfig::tile_size; ///< Tile size
  constexpr static auto dimension =
      ParallelConfig::dimension; ///< Dimension type
  constexpr static bool isChunkEdgePolicy = true;
  constexpr static bool isKokkosTeamPolicy =
      true; ///< Indicates that this is a Kokkos team policy
  ///@}

private:
  constexpr static int simd_size = simd::size();
  constexpr static bool using_simd = simd::using_simd;

public:
  /**
   * @name Constructors
   *
   */
  ///@{

  /**
   * @brief Construct a new element chunk policy
   *
   * @param view View of elements to chunk
   * @param ngll Number of GLL points along each edge
   */
  chunk_edge(const IndexViewType &index_view, int ngll)
      : policy_type(index_view.extent(0) / (tile_size * simd_size) +
                        (index_view.extent(0) % (tile_size * simd_size) != 0),
                    num_threads, vector_lanes),
        elements(index_view), ngll(ngll) {
#if KOKKOS_VERSION < 40100
    static_assert(IndexViewType::Rank == 1, "View must be rank 1");
#else
    static_assert(IndexViewType::rank() == 1, "View must be rank 1");
#endif
  }
  ///@}

  /**
   * @brief Implicit conversion to the underlying Kokkos policy type
   *
   * @return const policy_type & Underlying Kokkos policy type
   */
  operator const policy_type &() const { return *this; }

  /**
   * @brief Get iterator to iterator over chunk of edges associated with
   * Kokkos team
   *
   * @param start_index Starting index for the element within the team
   * @return iterator_type Iterator for the team
   */
  KOKKOS_INLINE_FUNCTION
  iterator_type league_iterator(const int start_index) const {
    const int start = start_index;
#define _min(a, b) ((a > b) ? b : a)
    const int end = _min(start + chunk_size * simd_size,
                         static_cast<int>(elements.extent(0)));
#undef _min
    // std::cout << "("<<start<<","<<end<<")"<<std::endl;
    const auto my_indices =
        Kokkos::subview(elements, Kokkos::make_pair(start, end));
    return iterator_type(my_indices, ngll);
  }

private:
  IndexViewType elements; ///< View of element indices
  int ngll;               ///< Number of GLL points along each edge
};
} // namespace policy
} // namespace specfem
