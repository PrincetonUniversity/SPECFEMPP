#pragma once

#include "point/point_container.hpp"
#include "specfem_setup.hpp"

namespace specfem {
namespace point {

namespace impl {
namespace properties {

// ===========================================================================
// 2D Point Properties
// ===========================================================================

/**
 * @defgroup specfem_point_properties_dim2_acoustic_isotropic 2D Acoustic
 * Properties
 * @{
 */

/**
 * @ingroup specfem_point_properties_dim2_acoustic_isotropic
 * @brief Data container to hold properties of 2D acoustic media at a quadrature
 * point
 *
 * @tparam UseSIMD Boolean indicating whether to use SIMD intrinsics
 *
 * <b> Accessor functions generated by the </b> \c POINT_CONTAINER \c MACRO
 *
 * - Get the inverse of density @f$ \frac{1}{\rho} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type rho_inverse() const @endcode
 *
 * - Get the bulk modulus @f$ \kappa @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type kappa() const @endcode
 *
 * <b> Additional accessor functions </b>
 *
 * - Get the inverse of bulk modulus @f$ \frac{1}{\kappa} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type kappa_inverse() const
 *   @endcode
 *
 * - Get the inverse of the product of density and P-wave velocity @f$
 * \frac{1}{\rho v_p} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type rho_vpinverse() const
 *   @endcode
 *
 */
template <bool UseSIMD>
struct data_container<specfem::dimension::type::dim2,
                      specfem::element::medium_tag::acoustic,
                      specfem::element::property_tag::isotropic, UseSIMD>
    : PropertyAccessor<specfem::dimension::type::dim2,
                       specfem::element::medium_tag::acoustic,
                       specfem::element::property_tag::isotropic, UseSIMD> {

private:
  using base_type = PropertyAccessor<
      specfem::dimension::type::dim2, specfem::element::medium_tag::acoustic,
      specfem::element::property_tag::isotropic, UseSIMD>; ///< Base type of the
                                                           ///< point properties
public:
  using value_type = typename base_type::value_type; ///< Type of the properties
  using simd = typename base_type::simd;

  POINT_CONTAINER(rho_inverse, kappa)

  KOKKOS_INLINE_FUNCTION const value_type kappa_inverse() const {
    return (static_cast<type_real>(1.0)) /
           kappa(); ///< @f$ \frac{1}{\lambda + 2\mu} @f$
  }

  KOKKOS_INLINE_FUNCTION const value_type rho_vpinverse() const {
    return Kokkos::sqrt(rho_inverse() * kappa_inverse()); ///< @f$ \frac{1}{\rho
                                                          ///< v_p} @f$
  }
};

///@} end of group specfem_point_properties_dim2_acoustic_isotropic

/**
 * @defgroup specfem_point_properties_elastic_isotropic Elastic
 * Isotropic Properties
 * @{
 */

/**
 * @ingroup specfem_point_properties_elastic_isotropic
 * @brief Data container to hold properties of elastic media at a quadrature
 * point
 *
 * @tparam UseSIMD Boolean indicating whether to use SIMD intrinsics
 *
 * <b> Accessor functions generated by the </b> \c POINT_CONTAINER \c MACRO
 *
 * - Get Kappa @f$ \kappa @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type kappa() const @endcode
 *
 * - Get shear modulus @f$ \mu @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type mu() const @endcode
 *
 * - Get density @f$ \rho @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type rho() const @endcode
 *
 * <b> Additional accessor functions </b>
 *
 * - Get Lame's parameter @f$ \lambda + 2\mu @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type lambdaplus2mu() const
 * @endcode
 *
 * - Compute the product of density and P-wave velocity squared, i.e., @f$ \rho
 *   v_p^2 = \rho (\lambda + 2\mu) @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type rho_vp() const @endcode
 *
 * - Compute the product of density and S-wave velocity squared, i.e., @f$ \rho
 *   v_s^2 = \rho \mu @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type rho_vs() const @endcode
 *
 * - Get Lame's first parameter @f$ \lambda @f$ from @f$ \lambda + 2\mu @f$ and
 *   @f$ \mu @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type lambda() const @endcode
 */
template <specfem::dimension::type DimensionTag,
          specfem::element::medium_tag MediumTag, bool UseSIMD>
struct data_container<
    DimensionTag, MediumTag, specfem::element::property_tag::isotropic, UseSIMD,
    std::enable_if_t<specfem::element::is_elastic<MediumTag>::value> >
    : public PropertyAccessor<DimensionTag, MediumTag,
                              specfem::element::property_tag::isotropic,
                              UseSIMD> {
private:
  using base_type = PropertyAccessor<DimensionTag, MediumTag,
                                     specfem::element::property_tag::isotropic,
                                     UseSIMD>; ///< Base type of the
                                               ///< point properties
public:
  using value_type = typename base_type::value_type; ///< Type of the properties

  using simd = typename base_type::simd;

  POINT_CONTAINER(kappa, mu, rho)

  KOKKOS_INLINE_FUNCTION const value_type lambdaplus2mu() const {
    return kappa() + (static_cast<type_real>(4.0 / 3.0)) * mu();
  }

  KOKKOS_INLINE_FUNCTION const value_type rho_vp() const {
    // we could compute this as sqrt((lambda + 2*mu) * rho())
    // but we prefer to use the definition
    // rho_vp = sqrt((lambda + 2*mu)/rho)) * rho
    // for better precision
    return Kokkos::sqrt(lambdaplus2mu() / rho()) * rho();
  }

  KOKKOS_INLINE_FUNCTION const value_type rho_vs() const {
    return Kokkos::sqrt(rho() * mu());
  }

  KOKKOS_INLINE_FUNCTION const value_type lambda() const {
    return lambdaplus2mu() - (static_cast<type_real>(2.0)) * mu();
  }
};
///@} end of group specfem_point_properties_elastic_isotropic

/**
 * @defgroup specfem_point_properties_dim2_elastic_isotropic_cosserat 2D Elastic
 * Isotropic Cosserat Properties
 * @{
 */

/**
 * @ingroup specfem_point_properties_dim2_elastic_isotropic_cosserat
 * @brief Template specialization for 2D elastic isotropic cosserat media
 *
 * @tparam UseSIMD Boolean indicating whether to use SIMD
 *
 * Parameters:
 * - rho: Density @f$ \rho @f$
 * - kappa: Bulk modulus @f$ \kappa @f$
 * - mu: Shear modulus @f$ \mu @f$
 * - nu: Coupling parameter @f$ \nu @f$
 * - j: Inertia density @f$ j @f$
 * - lambda_c: Cosserat Lame's first parameter @f$ \lambda_c @f$
 * - mu_c: Cosserat shear modulus @f$ \mu_c @f$
 * - nu_c: Cosserat Coupling parameter @f$ \nu_c @f$
 */
template <specfem::element::medium_tag MediumTag, bool UseSIMD>
struct data_container<
    specfem::dimension::type::dim2, MediumTag,
    specfem::element::property_tag::isotropic_cosserat, UseSIMD,
    std::enable_if_t<specfem::element::is_elastic<MediumTag>::value> >
    : public PropertyAccessor<
          specfem::dimension::type::dim2, MediumTag,
          specfem::element::property_tag::isotropic_cosserat, UseSIMD> {

private:
  using base_type =
      PropertyAccessor<specfem::dimension::type::dim2, MediumTag,
                       specfem::element::property_tag::isotropic_cosserat,
                       UseSIMD>; ///< Base type of the
                                 ///< point properties

public:
  using value_type = typename base_type::value_type; ///< Type of the properties
  using simd = typename base_type::simd;

  POINT_CONTAINER(rho, kappa, mu, nu, j, lambda_c, mu_c, nu_c)

  // lambda + 2 mu = kappa - 2/3*mu + 6/3 * mu
  KOKKOS_INLINE_FUNCTION const value_type lambdaplus2mu() const {
    return kappa() + static_cast<value_type>(4.0) /
                         static_cast<value_type>(3.0) *
                         mu(); ///< @f$ \lambda + 2\mu @f$
  }

  KOKKOS_INLINE_FUNCTION const value_type lambda() const {
    return kappa() - static_cast<value_type>(2.0) /
                         static_cast<value_type>(3.0) *
                         mu(); ///< @f$ \lambda + 2\mu @f$
  }

  KOKKOS_INLINE_FUNCTION const value_type rho_vp() const {
    return Kokkos::sqrt((kappa() + static_cast<value_type>(4.0) /
                                       static_cast<value_type>(3.0) * mu()) *
                        rho()); ///< @f$ \rho v_p @f$
  }

  KOKKOS_INLINE_FUNCTION const value_type rho_vs() const {
    return Kokkos::sqrt(rho() * mu()); ///< @f$ \rho v_s @f$
  }
};
///@} end of group specfem_point_properties_dim2_elastic_isotropic_cosserat

/**
 * @defgroup specfem_point_properties_dim2_elastic_anisotropic 2D Elastic
 * Anisotropic Properties
 * @{
 */

/**
 * @ingroup specfem_point_properties_dim2_elastic_anisotropic
 * @brief Data container to hold properties of 2D anisotropic elastic media at a
 * quadrature point
 *
 * @tparam UseSIMD Boolean indicating whether to use SIMD intrinsics
 *
 * <b> Accessor functions generated by the </b> \c POINT_CONTAINER \c MACRO
 *
 * - Get stiffness tensor component @f$ c_{11} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type c11() const @endcode
 *
 * - Get stiffness tensor component @f$ c_{13} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type c13() const @endcode
 *
 * - Get stiffness tensor component @f$ c_{15} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type c15() const @endcode
 *
 * - Get stiffness tensor component @f$ c_{33} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type c33() const @endcode
 *
 * - Get stiffness tensor component @f$ c_{35} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type c35() const @endcode
 *
 * - Get stiffness tensor component @f$ c_{55} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type c55() const @endcode
 *
 * - Get stiffness tensor component @f$ c_{12} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type c12() const @endcode
 *
 * - Get stiffness tensor component @f$ c_{23} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type c23() const @endcode
 *
 * - Get stiffness tensor component @f$ c_{25} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type c25() const @endcode
 *
 * - Get the density @f$ \rho @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type rho() const @endcode
 *
 * <b> Additional accessor functions </b>
 *
 * - Compute the product of density and P-wave velocity squared, i.e., @f$ \rho
 *   v_p^2 = \rho c_{33} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type rho_vp() const @endcode
 * - Compute the product of density and S-wave velocity squared, i.e., @f$ \rho
 *   v_s^2 = \rho c_{55} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type rho_vs() const @endcode
 *
 */
template <specfem::element::medium_tag MediumTag, bool UseSIMD>
struct data_container<
    specfem::dimension::type::dim2, MediumTag,
    specfem::element::property_tag::anisotropic, UseSIMD,
    std::enable_if_t<specfem::element::is_elastic<MediumTag>::value> >
    : public PropertyAccessor<specfem::dimension::type::dim2, MediumTag,
                              specfem::element::property_tag::anisotropic,
                              UseSIMD> {

private:
  using base_type =
      PropertyAccessor<specfem::dimension::type::dim2, MediumTag,
                       specfem::element::property_tag::anisotropic,
                       UseSIMD>; ///< Base type of the
                                 ///< point properties

public:
  using value_type = typename base_type::value_type; ///< Type of the properties
  using simd = typename base_type::simd;

  POINT_CONTAINER(c11, c13, c15, c33, c35, c55, c12, c23, c25, rho)

  KOKKOS_INLINE_FUNCTION const value_type rho_vp() const {
    return Kokkos::sqrt(rho() * c33()); ///< P-wave velocity @f$ \rho v_p @f$
  }

  KOKKOS_INLINE_FUNCTION const value_type rho_vs() const {
    return Kokkos::sqrt(rho() * c55()); ///< S-wave velocity @f$ \rho v_s @f$
  }
};
///@} end of group specfem_point_properties_dim2_elastic_anisotropic

/**
 * @defgroup specfem_point_properties_dim2_poroelastic_isotropic 2D Poroelastic
 * Isotropic Properties
 * @{
 */

/**
 * @ingroup specfem_point_properties_dim2_poroelastic_isotropic
 * @brief Data container to hold properties of 2D poroelastic media at a
 * quadrature point
 *
 * @tparam UseSIMD Boolean indicating whether to use SIMD intrinsics
 *
 * <b> Accessor functions generated by the </b> \c POINT_CONTAINER \c MACRO
 *
 * - Get porosity @f$ \phi @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type phi() const @endcode
 *
 * - Get solid density @f$ \rho_s @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type rho_s() const @endcode
 *
 * - Get fluid density @f$ \rho_f @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type rho_f() const @endcode
 *
 * - Get tortuosity @f$ \tau @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type tortuosity() const @endcode
 *
 * - Get shear modulus @f$ \mu_G @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type mu_G() const @endcode
 *
 * - Get Biot's modulus @f$ H_Biot @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type H_Biot() const @endcode
 *
 * - Get Biot's modulus @f$ C_Biot @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type C_Biot() const @endcode
 *
 * - Get Biot's modulus @f$ M_Biot @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type M_Biot() const @endcode
 *
 * - Get permeability tensor component @f$ k_{xx} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type permxx() const @endcode
 *
 * - Get permeability tensor component @f$ k_{xz} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type permxz() const @endcode
 *
 * - Get permeability tensor component @f$ k_{zz} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type permzz() const @endcode
 *
 * - Get fluid viscosity @f$ \eta_f @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type eta_f() const @endcode
 *
 * <b> Additional accessor functions </b>
 *
 * - Get Lame's parameter @f$ \lambda_G @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type lambda_G() const @endcode
 *
 * - Get Lame's parameter @f$ \lambda + 2\mu_G @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type lambdaplus2mu_G() const
 *   @endcode
 *
 * - Get the inverse of permeability tensor component @f$ k_{xx} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type inverse_permxx() const
 *   @endcode
 *
 * - Get the inverse of permeability tensor component @f$ k_{xz} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type inverse_permxz() const
 *   @endcode
 *
 * - Get the inverse of permeability tensor component @f$ k_{zz} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type inverse_permzz() const
 *   @endcode
 *
 * - Get the average density @f$ \rho_{bar} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type rho_bar() const @endcode
 *
 * - Get the P-wave velocity @f$ v_{pI} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type vpI() const @endcode
 *
 * - Get the P-wave velocity @f$ v_{pII} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type vpII() const @endcode
 *
 * - Get the S-wave velocity @f$ v_s @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type vs() const @endcode
 */
template <bool UseSIMD>
struct data_container<specfem::dimension::type::dim2,
                      specfem::element::medium_tag::poroelastic,
                      specfem::element::property_tag::isotropic, UseSIMD>
    : public PropertyAccessor<specfem::dimension::type::dim2,
                              specfem::element::medium_tag::poroelastic,
                              specfem::element::property_tag::isotropic,
                              UseSIMD> {

private:
  using base_type = PropertyAccessor<
      specfem::dimension::type::dim2, specfem::element::medium_tag::poroelastic,
      specfem::element::property_tag::isotropic, UseSIMD>; ///< Base type of the
                                                           ///< point properties

public:
  using value_type = typename base_type::value_type; ///< Type of the properties

  using simd = typename base_type::simd;

  POINT_CONTAINER(phi, rho_s, rho_f, tortuosity, mu_G, H_Biot, C_Biot, M_Biot,
                  permxx, permxz, permzz, eta_f)

  KOKKOS_INLINE_FUNCTION const value_type lambda_G() const {
    return H_Biot() - (static_cast<type_real>(2.0)) * mu_G();
  }

  KOKKOS_INLINE_FUNCTION const value_type lambdaplus2mu_G() const {
    return lambda_G() + (static_cast<type_real>(2.0)) * mu_G();
  }

  KOKKOS_INLINE_FUNCTION const value_type inverse_permxx() const {
    const value_type determinant =
        permxx() * permzz() - permxz() * permxz(); ///< determinant of the
                                                   ///< permeability tensor
    return permzz() / determinant; ///< inverse of the permeability tensor
  }

  KOKKOS_INLINE_FUNCTION const value_type inverse_permxz() const {
    const value_type determinant =
        permxx() * permzz() - permxz() * permxz(); ///< determinant of the
                                                   ///< permeability tensor
    return static_cast<type_real>(-1.0) * permxz() /
           determinant; ///< inverse of the permeability tensor
  }

  KOKKOS_INLINE_FUNCTION const value_type inverse_permzz() const {
    const value_type determinant =
        permxx() * permzz() - permxz() * permxz(); ///< determinant of the
                                                   ///< permeability tensor
    return permxx() / determinant; ///< inverse of the permeability tensor
  }

  KOKKOS_INLINE_FUNCTION const value_type rho_bar() const {
    return (((static_cast<type_real>(1.0) - this->phi()) * this->rho_s()) +
            (this->phi() * this->rho_f()));
  }

  KOKKOS_INLINE_FUNCTION const value_type vpI() const {
    ///< Helper variable for readability
    const auto phi_over_tort = this->phi() / this->tortuosity();
    const auto afactor = rho_bar() - phi_over_tort * rho_f();
    const auto bfactor =
        this->H_Biot() + phi_over_tort * rho_bar() / rho_f() * this->M_Biot() -
        static_cast<type_real>(2.0) * phi_over_tort * this->C_Biot();
    const auto cfactor =
        phi_over_tort / rho_f() *
        (this->H_Biot() * this->M_Biot() - this->C_Biot() * this->C_Biot());

    return Kokkos::sqrt(bfactor + Kokkos::sqrt(bfactor * bfactor -
                                               static_cast<type_real>(4.0) *
                                                   afactor * cfactor)) /
           (static_cast<type_real>(2.0) * afactor);
  }

  KOKKOS_INLINE_FUNCTION const value_type vpII() const {
    ///< Helper variable for readability
    const auto phi_over_tort = this->phi() / this->tortuosity();
    const auto afactor = rho_bar() - phi_over_tort * rho_f();
    const auto bfactor =
        this->H_Biot() + phi_over_tort * rho_bar() / rho_f() * this->M_Biot() -
        static_cast<type_real>(2.0) * phi_over_tort * this->C_Biot();
    const auto cfactor =
        phi_over_tort / rho_f() *
        (this->H_Biot() * this->M_Biot() - this->C_Biot() * this->C_Biot());

    return Kokkos::sqrt(bfactor - Kokkos::sqrt(bfactor * bfactor -
                                               static_cast<type_real>(4.0) *
                                                   afactor * cfactor)) /
           (static_cast<type_real>(2.0) * afactor);
  }

  KOKKOS_INLINE_FUNCTION const value_type vs() const {
    ///< Helper variable for readability
    const auto phi_over_tort = this->phi() / this->tortuosity();
    const auto afactor = rho_bar() - phi_over_tort * rho_f();
    return Kokkos::sqrt(mu_G() / afactor);
  }
};
/**@} end of group specfem_point_properties_dim2_poroelastic_isotropic */

/**
 * @defgroup specfem_point_properties_dim2_electromagnetic_isotropic 2D
 * Electromagnetic Isotropic Properties
 * @{
 */

/**
 * @brief Data container to hold properties of 2D electromagnetic media at a
 * quadrature point
 *
 * @tparam UseSIMD Boolean indicating whether to use SIMD intrinsics
 *
 * <b> Accessor functions generated by the </b> \c POINT_CONTAINER \c MACRO
 *
 * - Get the inverse of permeability @f$ \frac{1}{\mu_0} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type mu0_inv() const @endcode
 *
 * - Get permittivity tensor component @f$ \epsilon_{11} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type eps11() const @endcode
 *
 * - Get permittivity tensor component @f$ \epsilon_{33} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type eps33() const @endcode
 *
 * - Get conductivity tensor component @f$ \sigma_{11} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type sig11() const @endcode
 *
 * - Get conductivity tensor component @f$ \sigma_{33} @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type sig33() const @endcode
 */
template <specfem::element::medium_tag MediumTag, bool UseSIMD>
struct data_container<
    specfem::dimension::type::dim2, MediumTag,
    specfem::element::property_tag::isotropic, UseSIMD,
    std::enable_if_t<specfem::element::is_electromagnetic<MediumTag>::value> >
    : public PropertyAccessor<specfem::dimension::type::dim2, MediumTag,
                              specfem::element::property_tag::isotropic,
                              UseSIMD> {

private:
  using base_type = PropertyAccessor<specfem::dimension::type::dim2, MediumTag,
                                     specfem::element::property_tag::isotropic,
                                     UseSIMD>; ///< Base type of the
                                               ///< point properties

public:
  using value_type = typename base_type::value_type; ///< Type of the properties

  using simd = typename base_type::simd;

  POINT_CONTAINER(mu0_inv, eps11, eps33, sig11, sig33)
};

/** @} end of group specfem_point_properties_dim2_electromagnetic_isotropic */

} // namespace properties

} // namespace impl

/**
 * @brief Properties of a quadrature point in a 2D medium
 *
 * @tparam Dimension The dimension of the medium
 * @tparam MediumTag The type of the medium
 * @tparam PropertyTag The type of the properties
 * @tparam UseSIMD Boolean indicating whether to use SIMD intrinsics
 */
template <specfem::dimension::type Dimension,
          specfem::element::medium_tag MediumTag,
          specfem::element::property_tag PropertyTag, bool UseSIMD>
struct properties : impl::properties::data_container<Dimension, MediumTag,
                                                     PropertyTag, UseSIMD> {

  using base_type = impl::properties::data_container<Dimension, MediumTag,
                                                     PropertyTag, UseSIMD>;

  using value_type = typename base_type::value_type;
  using simd = typename base_type::simd;

  using base_type::base_type;
};

} // namespace point
} // namespace specfem
