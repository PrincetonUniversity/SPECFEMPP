from dataclasses import dataclass

import numpy as np
from numpy.typing import ArrayLike


@dataclass(init=False, frozen=True)
class IndexMapping:
    """gmsh tags need not be consecutive. Someone who creates the mesh may choose indices
    such that numbers make sense from a human perspective. We do not want to skip indices
    in the model.

    We want to remap tags from tag_list[i] -> i to remove any skips, where `tag_list`
    is the array of tags, say generated by gmsh.model.mesh.get_nodes()[0], we expect to see.

    Any tag list (say from a `gmsh.model.mesh.get_elements()` call) can be renumbered
    by this remapping through the `apply()` method.
    """

    original_tag_list: np.ndarray
    """The tag list, representing the tags
    expected to be managed. This object's indexing is `0:original_tag_list.size`, where
    the original index `tag_list[i]` gets mapped to `i`.
    """

    _sorted_tag_inds: np.ndarray
    """Equal to `numpy.argsort(original_tag_list)`. This stores the indices of
    original_tag_list in order of increasing values.
    """

    _sorted_tag_list: np.ndarray
    """Equal to `original_tag_list[sorted_tag_inds]`. This stores the sorted list of tags, which
    can be used by numpy.searchsorted to element-wise find the index of a tag.
    """

    def __init__(self, node_tags: np.ndarray):
        object.__setattr__(self, "original_tag_list", node_tags)

        # self.sorted_tag_inds[original_tag] == compressed_tag
        object.__setattr__(self, "_sorted_tag_inds", np.argsort(node_tags))
        object.__setattr__(self, "_sorted_tag_list", node_tags[self._sorted_tag_inds])

    def apply(self, arr: ArrayLike) -> np.ndarray:
        """Takes an array of tags, remapping them according to the rule given by this object.

        Args:
            arr (ArrayLike): The array to remap

        Returns:
            np.ndarray: Remapped indices, in the same shape of `arr`.
        """
        return self._sorted_tag_inds[np.searchsorted(self._sorted_tag_list, arr)]

    def invert(self, arr) -> np.ndarray:
        """Inverse of apply()"""
        return self.original_tag_list[arr]

    @staticmethod
    def join(a: "IndexMapping", b: "IndexMapping") -> "IndexMapping":
        """Creates an IndexMapping that includes tags from both arguments."""
        return IndexMapping(
            np.unique_values(np.concatenate([a.original_tag_list, b.original_tag_list]))
        )
